[TOC]

JAVA8     
SpringBoot2.1.0    SpringCloud2.0.0
SWAGGER

#  Gateway
	使用OpenRestry编写lua脚本对nginx进行扩展。
	还有另外一种，API Gateway，到时具体再研究。

# 各种坑
1. @Asyn 不能在同一类中，否则失效。

# 技术选型

> 参考：https://blog.csdn.net/matthewei6/article/details/50513624

# 设计
## 设计原则 
	1.单一职责原则
	2.里氏替换原则
	3.依赖倒置原则
	4.接口隔离原则
	5.迪米特法则
	6.开闭原则

# 高级
	Spark替代springboot。https://www.jdon.com/51806

##  设计
### 设计框架
	MVC
	MVP
	MVVM: Model view/view model

## 扩展

	横向扩展 也叫 水平扩展，用更多的节点支撑更大量的请求。 如成千上万的蚂蚁完成一项搬运工作。	
	纵向扩展 又叫 垂直扩展，扩展一个点的能力支撑更大的请求。如利用1个人的能力，如蜘蛛侠逼停火车。
	
	引https://blog.csdn.net/kingmax54212008/article/details/72721772

>前端：android/Jquery/LayUI/ztree/echarts/
>开源框架：
>	  SpringBoot/hibernate/Mybatis
>	  redis/ActiveMQ/Solar/CAS
>规范等：
>	 JPA/设计模式/restful
>数据库: mysql/mongodb
>文档工具：swagger/markdown/excel
>系统: centerOS 7.5/XServer/docker/k8s/nginx/tomcat/
>开发平台：idea/eclipse/mac/ubuntu/windows/
>组件：lombok/
--------------------------
分布式的链路跟踪和监控 Dapper
ElasticSearch+Logstash+Kibana+Filebeats日志系统
Spring-cloud-stream-binder

架构：NIO/RPC
大数据：springCloud/es/Kafka/MC
Hadoop/hive 
spark mapreduce /flume /flink
Scala/Groovy/Clojure/KOTin/
人工智能：
机器学习：caffe/theano /keras/convnet/tensorflow/torch
算法：lr/adaboost/gmm/svm/crf/maxent/hmm/dnn/cnn/rnn/curennt
图像识别：
物体追踪:

物联网




## JAVA
web.xml
	监听器>过滤器>servlet

1. 监听器
    不对主流程进行设置，仅用于监听动作。
    实现方法：

  > implements  ServletContextListener 常用于对应监控application内置对象的创建和销毁。
  > implements  HttpSessionListener 常用于统计在线人数；
  > implements  ServletContextAttribtueEvent 常用于当访问某个页面时，出发一个request请求，执行requestInitialized方法；当页面关闭时，执行requestDestroyed方法。
  > implements  HttpSessionBindingListener 常用于Session数据的钝化与活化；

1. 过滤器
	配置对某些请求进行过滤，常用于编码。
	实现方法: implements Filter重写doFilter方法；
	原理：基于回调函数进行。
	> 执行顺序：
		过滤器A -> 过滤器B --> .... --> servlet,所以执行顺序与web.xml编写顺序有关。

1. 拦截器
    通常使用第三方，如：Spring AOP(Aspect Oriented Program)进行拦截设置。
    实现方法: @Aspect
    原理：使用java反射机制实现。

  > 是对OOP的一种补充，实现OO的平等面转换为立体面。实现原理是代理机制。

三者区别：
深度：过滤器仅在servlet前后执行，而拦截器不仅在前后，异常抛出后等均能捕捉； 
资源：拦截器(AOP)可在spring体系中的全部资源/对象等进行拦截，而过滤器却不支持；	

1. 自定义Annotation
   * 引入spring-boot-starter-aop包。
   * 编写annotation类
```
		@Document
   		@Target({ElementType.METHOD})
		@Retention(RetentionPolicy.RUNTIME)
		public @interface MyAnnotation{
            String source() default  "";
		}
```

   * 编写AOP， @Pointcut("@annotation(com.cc.aop.AuthorityAnnotation)")。
   * 在需要的方法/类/属性上增加@MyAnnotation("xxx")等；
   * 当执行时，进入AOP进行拦截，并按编写逻辑进行。

  ##  数据库
### Mysql
#### 引擎

1. innodb  
B-Tree原理：键值/指针/数据，每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。
参考：https://blog.csdn.net/gitchat/article/details/78787837
B+Tree原理：通常在 B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。

因此可以对 B+Tree 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。

1. Myisam  
引擎也是采用的 B+Tree 结构来作为索引结构

###深入  
参考： 

	https://blog.csdn.net/qq_36807862
	https://blog.csdn.net/qq_36807862/article/details/81289811
	https://www.cnblogs.com/chiangchou/p/mysql-8.html

###mysql优化
> 参考：http://blog.51cto.com/7038006/2065724  
> 参考:https://blog.csdn.net/xueji2012/article/details/80570049  


1. MySQL 性能优化：组成、表的设计
	开启查询缓存。避免某些 SQL 函数直接在 SQL 语句中使用，从而导致 Mysql 缓存失效。
	避免画蛇添足。目的是什么就取什么，例如某个逻辑是只需要判断是否存在女性，若是查到了一条即可，勿要全部都查一遍，此时要善用 limit。
	建合适的索引。所以要建在合适的地方，合适的对象上。经常操作 / 比较 / 判断的字段应该建索引。
	字段大小合宜。字段的取值是有限而且是固定的，这种情况下可以用 enum，IP 字段可以用 unsigned int 来存储。
	表的设计。垂直分割表，使得固定表与变长表分割，从而降低表的复杂度和字段的数目。

1. SQL 语句优化：避免全表扫描
	建索引：一般在 where 及 order by 中涉及到的列上建索引，尽量不要对可以重复的字段建索引。
	尽量避免在 where 中使用 !（<>）或 or，也不要进行 null 值判断。
	尽量避免在 where 中对字段进行函数操作、表达式操作。
	尽量避免使用 like- %，在此种情况下可以进行全文检索。


#SpringBoot
默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。


# redis
## 雪崩处理
* 定义
  雪崩是前端频繁访问缓存中不存在的数据，致使程序一直访问数据库。

* 处理机制
1. 使用**布隆过滤器机制**进行处理。如：

   ```
     BloomFilter filter =  BloomFilter.create(Funnels.integerFunnel(),1000000);//存放一百万的KEY，用于后续的判断，大小依据实际业务进行设置。
     filter.put("aadf");
    if (filter.mightContain("aaf")) {
    //已匹配
    } else {
    //无匹配
    }
    //BloomFilter 依赖com.google.common.hash.BloomFilter
   ```
原理是使用hash做为key的一个bitmap，默认0.3%的。

1. 使用**双层缓存**进行处理。如：

   ```
     	最上层设置带有过期标志的缓存；
     	第底层设置长期；
   ```
