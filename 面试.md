[TOC]
# SpringBoot
## 1. 为什么springboot默认json格式作为传输方式？
通过查看源码得知，springboot在WebMvcConfigurationSupport#addDefaultHttpMessageConverters(List<HttpMessageConverter<?>> messageConverters)中的messageConverters中converter是先到先服务，排列顺序为：

```java
ByteArrayHttpMessageConverter
StringHttpMessageConverter
ResourceHttpMessageConverter
ResourceRegionHttpMessageConverter
SourceHttpMessageConverter
AllEncompassingFormHttpMessageConverter
MappingJackson2HttpMessageConverter
MappingJackson2XmlHttpMessageConverter
MappingJackson2SmileHttpMessageConverter			
```

故执行MappingJackson2HttpMessageConverter，即JSON格式。

## 2.为什么HandlerInterceptor中的pre/post/after中方法参数为 Object handler?为何不是HandlerMethod handler?

```java
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
}
```

当controller中的方法为RequestMapping时，Object handdler实际处理类为HandlerMethod。也就是说在使用时，需要对Object handler进行判断用于场景的分析。当Controller方法为其它时，并不是HandlerMethod。所以spring为拓展其实方法而预留Object类型。

# java

## 1. JDK使用及优化
jps 显示java程序运行的ID；

jconsole 显示某线程的曲线，用于监控java程序运行状态；

## 2. String 为什么是final的？

1，线程安全

​	String.class类中源码value值为char[]型，通过final 修饰过后，不允许外部对其修改。

2，效率

​	由于在设计时，不允许外部对其更改，故外部更新String时，其之前的value不会更改，更新的只是外部引用的指向，所以效率较高。

​    另：下方示例a/b的hashCode值是一样的，故其引用 的均为堆中的“a”，值相同，hash值相同，但堆中所使用的变量不同。

```java
String a = "a";
String b = new String("a");
System.out.println(a.hashCode() == b.hashCode()); //true
System.out.println(a.equals(b)); //true
System.out.println(a == b);		//false
```

